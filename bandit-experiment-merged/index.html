<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid World Game</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <!-- INDEX -->
    <div id="INDEX" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="padding-50 font-30">Welcome!</div>
            <div class="index-instructions">In this study, we are looking to investigate people's decision making. We hope you enjoy participating.</div>
            <div class="index-instructions">The study shouldn't take longer than 20 minutes. You will be directed back to Prolific at the end.</div>
            <div class="index-instructions">Click Next to continue.</div>
          </aside>
          <div id="first-next">
            <button id="first-next" class="button enabled">Next</button>
          </div>
        </div>
    </div>

    <!-- PRECONSENT -->
    <div id="PRECONSENT" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="padding-50 font-30">Before we begin</div>
            <div class="index-instructions blue-coloured">Do not refresh this tab at any point, or you will no longer be able to access it.</div>
            <div class="index-instructions">Please consider going into fullscreen mode to avoid distractions.</div>
            <div class="index-instructions">Click Next to proceed to the consent pages.</div>
            <button id="second-next" class="button enabled">Next</button>
          </aside>
        </div>
    </div>

    <!-- CONSENT -->
    <div id="CONSENT" class="w">
        <div class="consent-wrapper">
            <h2 id="consent-first-sentence" class="consent">Informed Consent Form for online experiments on cognitive control</h2>
            <div class="consent">This is a psychology experiment being conducted by Dr. Peter Dayan, director of the Max Planck Institute for Biological Cybernetics, and the members of his lab. In order to consent to participate, you MUST meet the following criteria:</div>
            <div class="consent">
              <ul>
                <li>18 years of age or older.</li>
                <li>Fluent speaker of English.</li>
                <li>Have not previously participated in this experiment.</li>
              </ul>
            </div>
            <div class="consent">This study is designed to look at how people learn how to make decisions to accomplish their goals. In this task, you will be asked to make choices, play games, and answer questions related to those games.  The study will take about 20 minutes and will pay $3 plus a performance-dependent bonus of up to a maximum of $10. The performance bonus is explained in more detail in the instructions that follow.</div>
            <div class="consent">Your participation in this research is voluntary. You may refrain from answering any questions that make you uncomfortable and may withdraw your participation at any time without penalty by exiting this task and alerting the experimenter. You may choose not to complete certain parts of the task or answer certain questions. You may contact us at the address provided below if you have additional questions or concerns.</div>
            <div class="consent">Other than monetary compensation, participating in this study will provide no direct benefits to you. But we hope that this research will benefit society at large by contributing towards establishing a scientific foundation for improving people’s learning and cognitive control abilities.</div>
            <div class="consent">Your online username may be connected to your individual responses, but we will not be asking for any additional personally identifying information, and we will handle responses as confidentially as possible. We cannot however guarantee the confidentiality of information transmitted over the Internet. We will be keeping deidentified data collected as part of this experiment indefinitely. Data used in scientific publications will remain completely anonymous.</div>
            <div class="consent">If you have any questions about the study, feel free to contact our lab. Dr. Dayan and his lab members can be reached at <a href="mailto:kyblab.tuebingen@gmail.com">kyblab.tuebingen@gmail.com</a>.</div>
            <div class="consent">By selecting the “consent” option below, I acknowledge that I am 18 or older, that I am a fluent speaker of English, that I have read this consent form, and that I agree to take part in the research.</div>
            <div id="consent-buttons-wrapper" class="consent button-group">
              <button id="consent-given" class="button small-button enabled">I consent to participate</button>
              <button id="consent-rescinded" class="button small-button enabled">I do not consent to participate</button>
            </div>
        </div>
    </div>

    <!-- DATA-PROTECTION -->
    <div id="DATA-PROTECTION" class="w">
        <div class="consent-wrapper">
            <h2 id="consent-first-sentence" class="consent">Data Protection Form for online experiments on cognitive control</h2>
            <div class="consent">Please click <a href="./static/data-protection-form.pdf">here</a> to view our Data Protection Information Sheet. It is yours to keep.</div>
            <div class="consent">I have received and taken note of the Data Protection Information Sheet for this study. In doing so, I had sufficient time and opportunity to ask questions about data protection and reconsider my participation in the study. I am aware that:</div>
            <div class="consent">
              <ul>
                <li>The processing and use of the collected data occurs in a pseudoanonymised form within the scope of the legally prescribed provisions. As a general rule, the storage occurs in the form of answered questionnaires, as well as electronic data, for a duration of 10 years or longer, if this is required by the purpose of the study.</li>
                <li>By providing further personal data in pseudoanonymised form, collected personal data may be used for the preparation of anonymised scientific research work and may also be published and used in an anonymised form in medical journals and scientific publications, so that a direct assignment to my person cannot be established.</li>
                <li>The information obtained during the course of this study may also be sent in an anonymised form to cooperation partners within the scope of the European General Data Protection Regulation for scientific purposes and to cooperation partners outside of the European Union, i.e. to countries with a lower data protection level (this also applies to the USA).</li>
                <li>The data collected within the scope of the study can also be used and processed in the future inside of the Max Planck Institute.</li>
              </ul>
            </div>
            <div class="consent">I was informed about my rights. In particular, that at any time:</div>
            <div class="consent">
                <ul>
                  <li>I can withdraw this declaration of consent.</li>
                  <li>I can request information about my stored data and request the correction or blocking of data.</li>
                  <li>If I choose to stop participating in this study, I can request that any of my personal data associated with this study are immediately deleted or anonymised.</li>
                  <li>I can request that my personal data are handed out to me or to third parties (if technically feasible).</li>
                </ul>
            </div>
            <div class="consent">I hereby declare that:</div>
            <div class="consent">
                <ul>
                  <li>I have been adequately informed about the collection and processing of my personal data and rights.</li>
                  <li>I consent to the collection and processing of personal data within the scope of the study and its pseudoanonymised disclosure, so that only persons conducting the study can establish a link between the data and my person.</li>
                </ul>
            </div>
            <div class="consent">Your online username may be connected to your individual responses, but we will not be asking for any additional personally identifying information, and we will handle responses as confidentially as possible.</div>
            <div class="consent">We cannot however guarantee the confidentiality of information transmitted over the internet. We will keep deidentified data collected as part of this experiment indefinitely. Data used in scientific publications will remain completely anonymous.</div>
            <div class="consent consent-checkboxes">
                <input type="checkbox" id="checkbox-y">
                <label for="checkbox-y" class="checkbox-label">I agree to participate in this experiment.</label>
            </div>
            <div class="consent consent-checkboxes">
                <input type="checkbox" id="checkbox-z">
                <label for="checkbox-z" class="checkbox-label">I consent to the use of my data described in the Data Protection Information Sheet and confirm having received a copy of the Data Protection Sheet.</label>
            </div>
            <div class="consent consent-checkboxes">
                <input type="checkbox" id="checkbox-x">
                <label for="checkbox-x" class="checkbox-label">I consent to data transfer from the MPI for Biological Cybernetics encrypted database to the project-related collaborators: inside of the Max Planck Society and affiliated research institutes, or at partnering institutions like the University of Tuebingen and New York University.</label>
            </div>
            <div id="consent-buttons-wrapper" class="consent button-group">
                <button id="submit-button" class="button small-button disabled" disabled>Submit</button>
                <button id="data-consent-rescinded" class="button small-button enabled">I do not consent to all of the above</button>
            </div>
        </div>
    </div>

    <!-- INSTRUCTIONS1 -->
    <div id="INSTRUCTIONS1" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="progress-bar-container">
              <div class="progress-bar" id="page1"></div>
            </div>
            <div class="index-instructions">You are about to be presented with several cards.</div>
            <div class="index-instructions">You can click on these cards individually. When you click on a card it <span id="binary-dependent">may</span> reward you.</div>
            <div class="index-instructions"><span class="blue-coloured">Your task is to maximise your score by selecting the right cards.</span></div>
            <button id="nextButton1" class="button enabled">Next</button>
          </aside>
        </div>
    </div>

    <!-- INSTRUCTIONS2 -->
    <div id="INSTRUCTIONS2" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="progress-bar-container">
              <div class="progress-bar" id="page2"></div>
            </div>
            <div class="index-instructions">We call selecting a card a trial.</div>
            <div id="one" class="index-instructions">You can only make a set number of trials in each round. Once you run out of trials, the round is over.</div>
            <div id="two" class="index-instructions"><span class="blue-coloured">The chance that a card will reward you will not change throughout the entire game.</span></div>
            <div class="button-group">
              <button id="backButton2" class="move-screen-button button enabled">Back</button>
              <button id="nextButton2" class="move-screen-button button enabled">Next</button>
            </div>
          </aside>
        </div>
    </div>

    <!-- INSTRUCTIONS3 -->
    <div id="INSTRUCTIONS3" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="progress-bar-container">
              <div class="progress-bar" id="page3"></div>
            </div>
            <div class="index-instructions">You will begin the task with a bonus of €0.</div>
            <div class="index-instructions">The more points you score, the higher your bonus will become.</div>
            <div class="index-instructions"><span class="blue-coloured">We will add up all the points you get in all the rounds to calculate your final bonus.</span></div>
            <div class="button-group">
                <button id="backButton3" class="move-screen-button button enabled">Back</button>
                <button id="nextButton3" class="move-screen-button button enabled">Next</button>
            </div>
          </aside>
        </div>
    </div>

    <!-- INSTRUCTIONS4 -->
    <div id="INSTRUCTIONS4" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="progress-bar-container">
              <div class="progress-bar" id="page4"></div>
            </div>
            <div class="index-instructions">To give you an idea of how the cards will look, let's have a training round.</div>
            <div class="index-instructions">During the training round, all the cards will give you a reward of 0. All you have to do is click on any of the cards 8 times. These can be the same cards, or different cards.</div>
            <div class="index-instructions">When you're ready, press Train to continue. To select cards, use your mouse.</div>
            <div class="button-group">
                <button id="backButton4" class="move-screen-button button enabled">Back</button>
                <button id="trainingButton" class="move-screen-button button enabled">Train</button>
            </div>
          </aside>
        </div>
    </div>

    <!-- TRAIN -->
    <div id="TRAIN" class="w">
        <div class="wrapper">
            <div class="grid-info-wrapper">
              <div id="grid-container-training"></div>
              <aside class="info">
                <div class="box">
                  <div id="score-training">Score: 0</div>
                  <div id="moves-training">Trials left: 8</div>
                </div>
                <div id="trainingOver" class="padding-top-20 dark-grey-coloured">
                  Press on any of the cards 8 times.
                </div>
                <button id="trainingOverBut" class="button enabled gone">Next</button>
              </aside>
            </div>
        </div>
    </div>

    <!-- PREBEGIN1 -->
    <div id="PREBEGIN1" class="w">
        <div class="wrapper">
            <aside class="inter">
              <div class="progress-bar-container">
                <div class="progress-bar" id="page-prebegin1"></div>
              </div>
              <div id="real-thing" class="index-instructions">Now let's move onto the real thing.</div>
              <div class="index-instructions">First, let's give you a username. Click generate to create a username:</div>
              <div id="username-generation" class="index-instructions blue-coloured hidden">lumi7el</div>
              <button id="prebegin1" class="button enabled">Generate</button>
            </aside>
          </div>
    </div>

    <!-- PREBEGIN2 -->
    <div id="PREBEGIN2" class="w">
        <div class="wrapper">
            <aside class="inter">
              <div class="progress-bar-container">
                <div class="progress-bar" id="page-prebegin2"></div>
              </div>
              <div class="index-instructions">Great! Your username is lumi7el.</div>
              <div id="comparison-text" class="index-instructions"></div>
              <div class="index-instructions hide-on-comparison">Let's find that player. Click Search:</div>
              <div class="loader hide-on-comparison"></div>
              <div id="comparer" class="index-instructions blue-coloured hidden hide-on-comparison"><span id="comparer-name">Player 1</span> played <span id="clock">3:14.12</span> ago.</div>
              <div id="play-command" class="index-instructions hidden">Now it's time to get started with the real game. We'll have a quick check to make sure you understand everything, and then we're ready to Play!</div>
              <button id="prebegin2" class="button enabled">Search</button>
            </aside>
          </div>
    </div>

    <!-- CHECK -->
    <div id="CHECK" class="w">
        <div class="wrapper">
            <aside class="check-inter">
              <div class="padding-50 font-30">Checking test</div>
              <div class="check">
                  <div id="1" class="question">When I click on a card, it will always reward me.</div>
                  <div class="answers">
                      <label>True <input type="radio" name="question-1" value="true"></label>
                      <label> False <input type="radio" name="question-1" value="false"></label>
                  </div>
              </div>
              <div class="check">
                  <div id="2" class="question">How much I receive from a card may change after each trial.</div>
                  <div class="answers">
                      <label>True <input type="radio" name="question-2" value="true"></label>
                      <label> False <input type="radio" name="question-2" value="false"></label>
                  </div>
              </div>
              <div class="check">
                  <div id="3" class="question">I must maximise my score on the final round to get the highest bonus.</div>
                  <div class="answers">
                      <label>True <input type="radio" name="question-3" value="true"></label>
                      <label> False <input type="radio" name="question-3" value="false"></label>
                  </div>
              </div>
              <div class="check">
                  <div id="3a" class="question">My bonus depends on the scores of others.</div>
                  <div class="answers">
                      <label>True <input type="radio" name="question-3a" value="true"></label>
                      <label> False <input type="radio" name="question-3a" value="false"></label>
                  </div>
              </div>
              <div id="final-check" class="check">
                  <div id="4" class="question">n3ssiori played with exactly the same cards as me.</div>
                  <div class="answers">
                      <label>True <input type="radio" name="question-4" value="true"></label>
                      <label> False <input type="radio" name="question-4" value="false"></label>
                  </div>
              </div>
            </aside>
            <div id="correct" class="index-instructions gone">Perfect! When you're ready to play, click Play.</div>
            <button id="check-next" class="button">Check</button>
            <div id="error-msg" class="error hidden">There was a mistake. Please correct the highlighted question.</div>
          </div>
    </div>

    <!-- GAME -->
    <div id="GAME" class="w">
        <div class="wrapper">
            <div class="grid-info-wrapper">
              <div id="overlay"></div>
              <div id="comparison-information" class="gone">
                  <div class="comparison-box-text">
                    <p id="comparison-box-first-line" class="margin-bottom-10">In the last <span id="no-comparison-trials">2 trials,</span></p>
                    <p class="score-container">
                      <span class="align-left">You scored: </span>
                      <span class="spacer"></span>
                      <span id="player-score-since-last-comparison" class="align-right">100</span>
                    </p>
                    <p id="comparer-score-container" class="score-container">
                      <span class="align-left">n3ssiori scored: </span>
                      <span class="spacer"></span>
                      <span id="comparison-score-since-last-comparison" class="align-right">100</span>
                    </p>
                  </div>
                  <div id="read-comparison" class="hidden font-15">Press anywhere in the box to continue.</div>
              </div>
              <div id="grid-container"></div>
              <aside class="info">
                <div class="box">
                  <div id="score">Score: 0</div>
                  <div id="moves">Trials left: 50</div>
                </div>
                <div id="trialOver" class="padding-top-20 dark-grey-coloured gone">
                  Round over. Click Next to continue.
                </div>
                <button id="trialOverBut" class="button enabled gone">Next</button>
              </aside>
            </div>
        </div>
    </div>

    <!-- INTERMEDIARY -->
    <div id="INTERMEDIARY" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div id="scorer" class="padding-30">You scored: 10</div>
            <button id="rounder" class="button enabled">Next round</button>
          </aside>
        </div>
    </div>
    
    <!-- STANDINGS -->
    <div id="STANDINGS" class="w">
        <div class="wrapper">
            <aside class="inter">
              <div class="padding-50 font-30">Highest scores</div>
              <div class="chart-container">
                  <svg id="barChart" width="400" height="300"></svg>
              </div>
              <button id="next-round-button" class="button" disabled>Next Round</button>
            </aside>
        </div>
    </div>
    
    <!-- THANKS -->
    <div id="THANKS" class="w">
        <div class="thanks-wrapper">
            <aside class="inter">
              <div id="thanks-title" class="padding-50 font-30">You're finished!</div>
              <div class="index-instructions">Your highest score was: <span id="player-score-max">5</span> and your total score was: <span id="player-score-sum">5</span>. This translates to a bonus of <span id="bonus-calculation">€5</span>.</div>
              <div class="index-instructions">Please enter your information below.</div><div class="index-instructions">If you have any comments about the task, or about how you made your decisions, these would be very welcome. Please do not provide any identifiable information in your comments.</div><div class="index-instructions">Click the button to proceed to the final payment page.</div>
              <div id="final-user-input" class="final-user-input">
                <form class="demos">
                  <label for="gender">Gender:</label>
                  <div class="dropdown-wrapper">
                    <select id="gender" name="gender" class="dropdown">
                      <option value="prefer-not-to-say">Prefer not to say</option>
                      <option value="woman">Woman</option>
                      <option value="man">Man</option>
                      <option value="non-binary">Non-binary</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                  <br><br>
                  <label for="age">Age:</label>
                  <div class="dropdown-wrapper">
                    <select id="age" name="age" class="dropdown"></select>
                  </div>
                </form>
                <div class="comments">
                  <textarea id="comments" name="comments" placeholder="Leave your comments here..."></textarea>
                </div>
              </div>
              <div id="final-payment-button-wrapper">
                <button id="final-payment" class="button enabled">Final payment</button>
              </div>
            </aside>
          </div>
    </div>
    
    <!-- FINAL -->
    <div id="FINAL" class="w">
        <div class="wrapper">
          <aside class="inter">
            <div class="padding-50 font-30">Thank you!</div>
            <div class="index-instructions">We will redirect you to the Prolific payment page presently. Have a lovely rest of the day.</div>
          </aside>
        </div>
    </div>
    
    <!-- RESCINDED -->
    <div id="RESCINDED" class="w">
        <div class="wrapper">
          <aside class="inter">
              <div class="padding-50 font-30">Thank you for taking the time to look at the study. We have collected no information about you.</div>
              <div class="index-instructions">We hope you have a lovely rest of the day. Feel free to close this window at any time.</div>
          </aside>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let currentPage;
        var round = 1;
        let scoresSoFar = [];
        let comparersScoreSoFar = [];
        let settings;

        // Function to switch between pages and run specific scripts
        function showPage(pageId) {
            currentPage = pageId;
            const pages = document.querySelectorAll('.w');
            pages.forEach(page => page.style.display = 'none');
            document.getElementById(pageId).style.display = 'block';
            switch(pageId) {
                case 'INDEX':
                    loadIndex();
                    break;
                case 'PRECONSENT':
                    loadPreconsent();
                    break;
                case 'CONSENT':
                    loadConsent();
                    break;
                case 'DATA-PROTECTION':
                    loadDataProtection();
                    break;
                case 'INSTRUCTIONS1':
                    loadInstructions1();
                    break;
                case 'INSTRUCTIONS2':
                    loadInstructions2();
                    break;
                case 'INSTRUCTIONS3':
                    loadInstructions3();
                    break;
                case 'INSTRUCTIONS4':
                    loadInstructions4();
                    break;
                case 'TRAIN':
                    loadTraining();
                    break;
                case 'PREBEGIN1':
                    loadPrebegin1();
                    break;
                case 'PREBEGIN2':
                    loadPrebegin2();
                    break;
                case 'CHECK':
                    loadCheck();
                    break;
                case 'GAME':
                    loadGame();
                    break;
                case 'INTERMEDIARY':
                    loadIntermediary();
                    break;
                case 'STANDINGS':
                    loadStandings();
                    break;
                case 'THANKS':
                    loadThanks();
                    break;
                case 'FINAL':
                    loadFinal();
                    break;
                case 'RESCINDED':
                    loadRescinded();
                    break;
            }
        }

        // Initialize the first page
        document.addEventListener('DOMContentLoaded', () => showPage('INDEX'));

        async function loadIndex() {
            initializeFocusTracker();
            checkRefresh();

            const vars = await loadGameSettings();
            sessionStorage.setItem('gameSettings', JSON.stringify(vars));

            async function loadGameSettings() {
              const response = await fetch('settings.json');
              const data = await response.json();
              return data.vars;
            }

            buttonToNewPage('first-next', 'PRECONSENT');
        }

        function loadPreconsent() {
            buttonToNewPage('second-next', 'CONSENT');
        }

        function loadConsent() {
            document.addEventListener('DOMContentLoaded', async function() {
              document.getElementById('consent-given').addEventListener('click', function() {
                window.location.href = 'data-protection';
              });
              document.getElementById('consent-rescinded').addEventListener('click', function() {
                window.location.href = 'consent-rescinded';
              });
            });
            buttonToNewPage('consent-given', 'DATA-PROTECTION');
            buttonToNewPage('consent-rescinded', 'RESCINDED');
        }

        function loadDataProtection() {
            const submitButton = document.getElementById('submit-button');
            submitButton.style.cursor = 'not-allowed';
            const checkboxes = document.querySelectorAll('.consent-checkboxes input[type="checkbox"]');

            checkboxes.forEach(checkbox => {
                checkbox.style.cursor = 'pointer';
                checkbox.addEventListener('change', () => {
                    if (Array.from(checkboxes).every(cb => cb.checked)) {
                        submitButton.classList.remove('disabled');
                        submitButton.classList.add('enabled');
                        submitButton.disabled = false;
                        submitButton.style.cursor = 'pointer';
                    } else {
                        submitButton.classList.remove('enabled');
                        submitButton.classList.add('disabled');
                        submitButton.disabled = true;
                        submitButton.style.cursor = 'not-allowed';
                    }
                });
            });
            buttonToNewPage('submit-button', 'INSTRUCTIONS1');
            buttonToNewPage('data-consent-rescinded', 'RESCINDED');
        }

        function loadInstructions1() {
            const prolificID = 'prolificID';
            create_participant(prolificID);

            settings = getGameSettings();

            var playerData = {
              "player": {
                  "prolificID": prolificID,
              }
            };
            sessionStorage.setItem('playerData', JSON.stringify(playerData));

            if (settings.binary == false) {
                document.getElementById('binary-dependent').innerHTML = 'will';
            }
            buttonToNewPage('nextButton1', 'INSTRUCTIONS2');
        }


        function loadInstructions2() {
            var para1 = document.getElementById('one');
            var para2 = document.querySelector('#two .blue-coloured');
            var para3 = document.getElementById('three');

            if (settings.numberOfRounds < 2) {
              para1.innerHTML = 'You will have a set number of trials to make. Once you run out of trials, the experiment is over.';
              if (settings.stochastic == true) {
                if (settings.binary == false) {
                  para2.innerHTML = 'After every trial, each card will change how much it rewards you.';
                } else {
                  para2.innerHTML = 'After every trial, the chance that a card will reward you will change.';
                }
              } else {
                if (settings.binary == false) {
                  para2.innerHTML = 'Each card will provide a fixed reward, which is the same every trial.';
                } else {
                  para2.innerHTML = 'Each card has a fixed chance of rewarding you. And this chance is the same in every trial.';
                }
              }
            } else {
              para1.innerHTML = 'You will have ' + settings.numberOfRounds + ' rounds to maximise your score. In each round, you will have ' + settings.moves + ' trials. Once you run out of trials, the round is over.';
              if (settings.stochastic == true) {
                if (settings.binary == false) {
                  if (settings.rewardsChangeAcrossRounds == false) {
                    para2.innerHTML = 'After every trial, each card will change how much it rewards you. However, these changes are the same in every round.';
                  } else {
                    para2.innerHTML = 'After every trial, each card will change how much it rewards you.';
                  }
                } else {
                  para2.innerHTML = 'After every trial, the chance that a card will reward you will change.';
                }
              } else {
                if (settings.binary == false) {
                  para2.innerHTML = 'Each card will provide a fixed reward, which is the same in every round.';
                } else {
                  para2.innerHTML = 'Each card has a fixed chance of rewarding you. And this chance is the same in every round.';
                }
              }
            }
            buttonToNewPage('backButton2', 'INSTRUCTIONS1');
            buttonToNewPage('nextButton2', 'INSTRUCTIONS3');
        }


        function loadInstructions3() {
            buttonToNewPage('backButton3', 'INSTRUCTIONS2');
            buttonToNewPage('nextButton3', 'INSTRUCTIONS4');
        }


        function loadInstructions4() {
            buttonToNewPage('backButton4', 'INSTRUCTIONS3');
            buttonToNewPage('trainingButton', 'TRAIN');
        }

        async function loadTraining() {
            let isClickable = true;

            const trainingSettings = await loadTrainingSettings();
            async function loadTrainingSettings() {
              let response;
              if (settings.stochastic) {
                response = await fetch('training-settings-stochastic.json');
              } else {
                response = await fetch('training-settings-non-stochastic.json');
              }
              const data = await response.json();
              return data.vars;
            }

            const gridContainer = document.getElementById('grid-container-training');
            const movesText = document.getElementById('moves-training');

            const initialStochasticValue = 0.5;
            const initialPurpleValue = 0.;
            const round = 1;
            var currentMove = 0;

            const numberOfMoves = 8;
            const rows = trainingSettings.rows;
            const cols = trainingSettings.cols;
            const decay = trainingSettings.decay;
            const decayCenter = trainingSettings.decayCenter;
            const noiseStdDev = trainingSettings.noiseStdDev;
            const stochastic = settings.stochastic;
            const stochasticValues = trainingSettings.stochasticValues;
            const purpleValues = trainingSettings.purpleValues;
            const binary = settings.binary;
            const meanValues = trainingSettings.meanValues;
            const chanceToWin = trainingSettings.chanceToWin;
            const chanceToWinPurple = trainingSettings.chanceToWinPurple;

            const numberOfRounds = settings.numberOfRounds;
            const roundsUntilPurple = settings.roundsUntilPurple;
            const greenSquareScore = settings.greenSquareScore;
            const purpleSquareScore = settings.purpleSquareScore;

            let score = 0, previousScore = 0;
            const successScore = settings.stochastic ? 500 : 100;
            let decision = Array(), rewardReceived = Array(), timeStamps = Array();
            setupGrid();

            function gameLogic(square) {
                if (currentMove > 7) {
                    return;
                }
                revealSquare(square);

                decision[currentMove] = square;
                timeStamps[currentMove] = new Date().toISOString().split('T')[1];

                currentMove = currentMove + 1;

                movesText.innerHTML = 'Trials left: ' + (numberOfMoves - currentMove);

                if (currentMove > 7) {
                  endTrialLogic(successScore, decision, rewardReceived, timeStamps);
                }
            }

            function endTrialLogic(successScore, decision, rewardReceived, timeStamps) {
              saveTrainingData(decision, rewardReceived, timeStamps);
              document.getElementById('trainingOverBut').classList.remove('gone');
              document.getElementById('trainingOver').innerHTML = 'Nice! You selected ' + numberOfMoves + ' cards.';
              buttonToNewPage('trainingOverBut', 'PREBEGIN1');
              return;
            }

            function revealSquare(square) {
                square.classList.remove('grey');
                square.classList.add('white');
                const squareX = parseFloat(square.id.split(',')[0]);
                const squareY = parseFloat(square.id.split(',')[1]);
                var additionalScore = 0;
                var randomVal = Math.random();
                if (binary) {
                    if (randomVal < chanceToWin[currentMove][squareY][squareX]) { // CHANCE TO WIN IS HERE!
                      if (round >= roundsUntilPurple && randomVal < chanceToWinPurple[currentMove][squareY][squareX]) {
                        additionalScore = purpleSquareScore;
                        makePurple(square, additionalScore);
                      } else {
                        additionalScore = greenSquareScore;
                        makeGreen(square, additionalScore);
                      }
                    }
                } else {
                    if (round >= roundsUntilPurple && randomVal < chanceToWinPurple[currentMove][squareY][squareX]) {
                        additionalScore = purpleSquareScore;
                        makePurple(square, additionalScore);
                    } else {
                      additionalScore = Math.round(chanceToWin[currentMove][squareY][squareX] * 100);
                      makeGreen(square, additionalScore);
                    }
                }
                setTimeout(() => {
                    square.classList.remove('white');
                    square.classList.add('grey');
                }, 500);
                return additionalScore;
            }

            function makeGreen(square, additionalScore) {
                const pseudoElement = document.createElement('div');
                pseudoElement.classList.add('green');
                const text = document.createElement('div');
                text.classList.add('square-score');
                text.innerHTML = '0';
                pseudoElement.appendChild(text);
                square.appendChild(pseudoElement);
                square.classList.add('greenish');
                setTimeout(() => {
                    square.classList.remove('greenish');
                    square.classList.remove('white');
                    square.classList.add('grey');
                    square.removeChild(pseudoElement);
                }, 700);
            }

            function makePurple(square, additionalScore) {
                const pseudoElement = document.createElement('div');
                pseudoElement.classList.add('gold');
                const text = document.createElement('div');
                text.classList.add('square-score');
                text.innerHTML = '';
                pseudoElement.appendChild(text);
                square.appendChild(pseudoElement);
                square.classList.add('goldish');
                setTimeout(() => {
                    square.classList.remove('goldish');
                    square.classList.remove('white');
                    square.classList.add('grey');
                    square.removeChild(pseudoElement);
                }, 700);
            }

            function updateTextColor(scoreText, score, previousScore) {
                const originalColor = 'black';
                var newColor = 'black';
                var timeout = 300;
                if ((score - previousScore) == greenSquareScore) {
                    newColor = '#228833';
                    timeout = 500;
                } else if ((score - previousScore) == purpleSquareScore) {
                    newColor = '#AA3377';
                    timeout = 500;
                } else if (score < previousScore) {
                    newColor = '#BBBBBB'; //red:#F05039
                }
                scoreText.style.color = newColor;
                setTimeout(() => {
                    scoreText.style.color = originalColor;
                }, timeout);
            }

            function setupGrid() {
              const padding = 10;
              const minDimension = Math.min(window.innerWidth, window.innerHeight - rows * padding);
              const squareSize = (minDimension / Math.max(rows, cols)) - padding;

              gridContainer.innerHTML = '';
              gridContainer.style.gridTemplateColumns = `repeat(${cols}, ${squareSize + padding}px)`;
              gridContainer.style.gridTemplateRows = `repeat(${rows}, ${squareSize + padding}px)`;

              createGridSquares(rows, cols, squareSize, padding);
            }

            function createGridSquares(rows, cols, squareSize, padding) {
              for (let y = 0; y < rows; y++) {
                  for (let x = 0; x < cols; x++) {
                      const square = createSquare(x, y, squareSize, padding);
                      gridContainer.appendChild(square);
                  }
              }
            }

            function createSquare(x, y, squareSize, padding) {
              const square = document.createElement('div');
              square.id = `${x},${y}`;
              square.classList.add('square');
              square.classList.add('grey');
              square.style.width = square.style.height = squareSize + 'px';
              square.style.borderRadius = '5px';
              square.style.margin = `${padding / 2}px`;

              square.addEventListener('click', function(event) {
                  if (isClickable) {
                      isClickable = false;
                      gameLogic(square);
                      setTimeout(() => {
                          isClickable = true;
                      }, 500); // 500 ms debounce time
                  }
              });

              return square;
            }

            function convertXY2Square(x, y) {
              return y * cols + x;
            }

            function convertXY2Square(x, y) {
              return gridSize * y + x;
            }

            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [array[i], array[j]] = [array[j], array[i]];
              }
            }

            function gaussianRandom(mean=0, stdev=1) { //stackOverflow
              const u = 1 - Math.random(); // Converting [0,1) to (0,1]
              const v = Math.random();
              const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
              // Transform to the desired mean and standard deviation:
              return z * stdev + mean;
            }
            
            function saveTrainingData(decision, rewardReceived, timeStamps) {
              // Create the main object with the trainingData label
              const data = {
                      move: {}
              };

              // Populate the trainingData object
              let squareX;
              let squareY;
              decision.forEach((square, index) => {
                  squareX = parseFloat(square.id.split(',')[0]);
                  squareY = parseFloat(square.id.split(',')[1]);
                  data.move[index] = {
                      decisionX: squareX,
                      decisionY: squareY,
                      reward: rewardReceived[index],
                      timestamp: timeStamps[index]
                  };
              });

              // Convert the data object to a JSON string
              const dataJSON = JSON.stringify(data);

              // Store the JSON string in sessionStorage
              sessionStorage.setItem("trainingData", dataJSON);
            }
        }

        function loadPrebegin1() {
            if (!settings.binary) {
              if (settings.stochastic) {
                document.getElementById('real-thing').innerHTML = 'Now let\'s move onto the real thing. This time there will be some reward associated with every card. However, this reward may change every trial.';
              } else {
                document.getElementById('real-thing').innerHTML = 'Now let\'s move onto the real thing. This time there will be some reward associated with every card.';
              }
            } else {
              document.getElementById('real-thing').innerHTML = 'Now let\'s move onto the real thing. This time there is some chance that each card will reward you after you select it.';
            }

            const prebegin1Butt = document.getElementById('prebegin1');
            prebegin1Butt.addEventListener('click', generateUsername);
            prebegin1Butt.disabled = false;

            let pressedOnce = false;
            let debounceTimeout;

            function generateUsername() {
                if (prebegin1Butt.disabled) {
                    return;
                }

                if (debounceTimeout) {
                    clearTimeout(debounceTimeout);
                }

                prebegin1Butt.disabled = true;
                prebegin1Butt.classList.remove('enabled');
                prebegin1Butt.style.cursor = 'not-allowed';
                prebegin1Butt.style.color = 'grey';
                debounceTimeout = setTimeout(() => {
                    if (!pressedOnce) {
                        pressedOnce = true;
                        setTimeout(() => {
                            document.getElementById('username-generation').style.visibility = 'visible';
                        }, 700);

                        setTimeout(() => {
                            prebegin1Butt.disabled = false;
                            prebegin1Butt.innerHTML = 'Next';
                            prebegin1Butt.classList.add('enabled');
                            prebegin1Butt.style.color = 'black';
                            prebegin1Butt.style.cursor = 'pointer';
                        }, 3000);
                    } else {

                        showPage('PREBEGIN2');
                    }
                }, 700);
            }
        }

        function loadPrebegin2() {
            const prebegin2Butt = document.getElementById('prebegin2');
            prebegin2Butt.addEventListener('click', generateCopmarisonTarget);

            if (!settings.includeComparison) {
              Array.from(document.getElementsByClassName('hide-on-comparison')).forEach(element => element.style.display = 'none');
              prebegin2Butt.innerHTML = 'Quick check';
              document.getElementById('play-command').style.visibility = 'visible';
              document.getElementById('comparison-text').style.display = 'none';
            } else {
              if (!settings.comparisonOnNewPage) {
                if (settings.comparisonFrequency < 2) {
                  document.getElementById('comparison-text').innerHTML = 'After every trial, we will show you the score of another player who previously played with exactly the same cards as you.';
                  if (settings.comparisonFrequencyRounds > 1) {
                    document.getElementById('comparison-text').innerHTML = 'After every trial, we will show you the score of another player who previously played with exactly the same cards as you. This may not happen immediately.';
                  }
                } else {
                  document.getElementById('comparison-text').innerHTML = 'Every ' + settings.comparisonFrequency + ' trials, we will show you the average score of another player who previously played with exactly the same cards as you.';
                  if (settings.comparisonFrequencyRounds > 1) {
                    document.getElementById('comparison-text').innerHTML = 'Every ' + settings.comparisonFrequency + ' trials, we will show you the average score of another player who previously played with exactly the same cards as you. This may not happen immediately.';
                  }
                }
              } else {
                if (settings.numberOfRounds > 1) {
                  if (settings.numberOfRounds / settings.comparisonFrequencyRounds > 2.1) {
                    if (settings.comparisonFrequencyRounds == 1) {
                    document.getElementById('comparison-text').innerHTML = 'You will play ' + settings.numberOfRounds + ' rounds in total. After every round, we will show you the average score of another player who previously played with exactly the same cards as you.'
                    } else {
                      document.getElementById('comparison-text').innerHTML = 'You will play ' + settings.numberOfRounds + ' rounds in total. After every ' + settings.comparisonFrequencyRounds + ' rounds, we will show you the average score of another player who previously played with exactly the same cards as you.'
                    }
                  } else {
                    if (settings.comparisonFrequencyRounds == 1) {
                      document.getElementById('comparison-text').innerHTML = 'You will play ' + settings.numberOfRounds + ' rounds in total. After the first round, we will show you the average score of another player who previously played with exactly the same cards as you.'
                    } else {
                      document.getElementById('comparison-text').innerHTML = 'You will play ' + settings.numberOfRounds + ' rounds in total. After round ' + settings.comparisonFrequencyRounds + ', we will show you the average score of another player who previously played with exactly the same cards as you.'
                    }
                    
                  }
                }
              }
            }

            var pressedOnce = false;
            function generateCopmarisonTarget() {
              if (!settings.includeComparison) {
                showPage('CHECK');
                return;
              }
              if (prebegin2Butt.disabled) {
                return;
              }
              if (!pressedOnce) {
                document.querySelector('.loader').style.display = 'block';

                pressedOnce = true;
                prebegin2Butt.disabled = true;
                prebegin2Butt.classList.remove('enabled');
                prebegin2Butt.style.cursor = 'not-allowed';
                prebegin2Butt.style.color = 'grey';
                setTimeout(() => {
                  document.getElementById('comparer').style.visibility = 'visible';
                  document.getElementById('comparer-name').innerHTML = 'n3ssiori';
                  document.querySelector('.loader').style.display = 'none';
                  var clock = document.getElementById('clock');
                  var startTime = new Date();
                  startTime.setHours(startTime.getHours() - 3);
                  startTime.setMinutes(startTime.getMinutes() - 14);
                  startTime.setSeconds(startTime.getSeconds() - 12); // Set start time to 3 hours, 14 minutes, and 12 seconds ago
                  function updateClock() {
                    var currentTime = new Date();
                    
                    var elapsedTime = currentTime - startTime; // Get the elapsed time in milliseconds
                    var seconds = Math.floor(elapsedTime / 1000); // Convert milliseconds to seconds
                    
                    var hours = Math.floor(seconds / 3600); // Calculate hours
                    seconds %= 3600;
                    var minutes = Math.floor(seconds / 60); // Calculate minutes
                    seconds %= 60; // Calculate remaining seconds
                    
                    clock.textContent = hours + ':' + minutes.toString().padStart(2, '0') + '.' + seconds.toString().padStart(2, '0');
                  }
                  setInterval(updateClock, 10); // Update the clock every 10 milliseconds
                }, 6530);
                
                setTimeout(() => {
                  document.getElementById('play-command').style.visibility = 'visible';
                  prebegin2Butt.disabled = false;
                  prebegin2Butt.innerHTML = 'Quick check';
                  prebegin2Butt.classList.add('enabled');
                  prebegin2Butt.style.color = 'black';
                  prebegin2Butt.style.cursor = 'pointer';
                }, 8000);
              } else {
                showPage('CHECK');
              }
            }
        }

        function loadCheck() {
            const submitButton = document.getElementById('check-next');
            let correctAnswers;
            if (settings.includeComparison) {
              correctAnswers = [
                { question: "1", answer: !settings.binary },
                { question: "2", answer: !settings.binary },
                { question: "3", answer: false },
                { question: "3a", answer: false },
                { question: "4", answer: true }
              ];
            } else {
              document.getElementById('final-check').style.display = 'none';
              correctAnswers = [
                { question: "1", answer: !settings.binary },
                { question: "2", answer: !settings.binary },
                { question: "3", answer: false },
                { question: "3a", answer: false }
              ];
            }

            let answers = [];
            let checkedAnswerLog = [];
            let questions = document.querySelectorAll('.check');
            questions.forEach(question => {
                let qID = question.querySelector('.question').id;
                question.querySelectorAll('input[type="radio"]').forEach(answer => {
                  answer.addEventListener('change', () => {
                    document.getElementById('error-msg').style.visibility = 'hidden';
                    question.querySelector('.question').style.color = '#333';
                    if (answer.checked) {
                      answers.push({
                        question: qID,
                        answer: answer.value === 'true' ? true : false,
                        timestamp: new Date().toISOString().split('T')[1]
                      });
                    }
                    if (new Set(answers.map(item => item.question)).size > correctAnswers.length - 1) { // if we have enough answers, release Check button
                        submitButton.classList.remove('disabled');
                        submitButton.classList.add('enabled');
                        submitButton.disabled = false;
                        submitButton.style.cursor = 'pointer';
                    }
                  });
                });
            });

            if (new Set(answers.map(item => item.question)).size < correctAnswers.length) { // else cannot Check until all answers complete
              submitButton.classList.add('disabled');
              submitButton.disabled = true;
              submitButton.style.cursor = 'not-allowed';
            }

            submitButton.addEventListener('click', () => {
              let questionsChecked = [];
              checkedAnswerLog.push({timestamp: new Date().toISOString().split('T')[1]});
              for (let i = answers.length - 1; i >= 0; i--) { // work backwards because of updating answers
                let userAnswer = answers[i];
                if (questionsChecked.includes(userAnswer.question)) {
                  continue;
                }
                questionsChecked.push(userAnswer.question);
                let correctAnswer = correctAnswers.find(answer => answer.question === userAnswer.question);
                if (userAnswer.answer !== correctAnswer.answer) {
                  let questionElement = document.getElementById(userAnswer.question);
                  //let selectedRadio = questionElement.nextElementSibling.querySelector(`input[type="radio"][value="${userAnswer.answer.toString()}"]`);
                  //selectedRadio.style.accentColor = '#b50000';
                  questionElement.style.color = '#b50000';
                  document.getElementById('error-msg').style.visibility = 'visible';
                  return;
                }
              }
              let checkQuestions = {
                answers: answers,
                checkedAnswerLog: checkedAnswerLog
              };
              sessionStorage.setItem('checkQuestions', JSON.stringify(checkQuestions));
              document.getElementById('correct').classList.remove('gone');
              document.getElementById('final-check').style.marginBottom = '0px';
              submitButton.innerHTML = 'Play';
              buttonToNewPage('check-next', 'GAME');

              submitButton.classList.add('disabled');
              submitButton.disabled = true;
              submitButton.style.cursor = 'not-allowed';
              setTimeout(() => {
                  submitButton.classList.remove('disabled');
                  submitButton.classList.add('enabled');
                  submitButton.disabled = false;
                  submitButton.style.cursor = 'pointer';
              }, 2000);
            });
        }

        async function loadGame() {
            let isClickable = true;

            const gridContainer = document.getElementById('grid-container');
            const movesText = document.getElementById('moves');
            const scoreText = document.getElementById('score');

            let movesSinceLastComparison = 0;
            let scoreSinceLastComparison = 0;
            const initialStochasticValue = 0.5;
            const initialPurpleValue = 0.;

            const numberOfMoves = settings.moves;
            var movesRemaining = settings.moves;

            const rows = settings.rows;
            const cols = settings.cols;
            const decay = settings.decay;
            const decayCenter = settings.decayCenter;
            const noiseStdDev = settings.noiseStdDev;
            const stochastic = settings.stochastic;
            const stochasticValues = settings.stochasticValues;
            const purpleValues = settings.purpleValues;
            const binary = settings.binary;
            const meanValues = settings.meanValues;
            const chanceToWin = settings.chanceToWin;
            const chanceToWinPurple = settings.chanceToWinPurple;

            const numberOfRounds = settings.numberOfRounds;
            const includeComparison = settings.includeComparison;
            const comparisonFrequencyRounds = settings.comparisonFrequencyRounds;
            const comparisonFrequency = settings.comparisonFrequency;
            const comparisonOnNewPage = settings.comparisonOnNewPage;
            const probUpwardComparison = settings.probUpwardComparison;
            const comparisonMean = settings.comparisonMean;
            const comparisonStdDev = settings.comparisonStdDev;
            const greenSquareScore = settings.greenSquareScore;
            const purpleSquareScore = settings.purpleSquareScore;

            if (!includeComparison) {
              document.getElementById("comparer-score-container").classList.remove("score-container");
              document.getElementById("comparer-score-container").classList.add("gone");
            }

            let score = 0, previousScore = 0, comparersScore = 0;

            let decision = Array(numberOfMoves), rewardReceived = Array(numberOfMoves), comparison = Array(numberOfMoves), timeStamps = Array(numberOfMoves);
            setupGrid();

            initialise();

            function initialise() {
                document.getElementById("trialOver").classList.add("gone");
                document.getElementById("trialOverBut").classList.add("gone");
                scoreText.innerHTML = 'Score: ' + score;
                movesText.innerHTML = 'Trials left: ' + movesRemaining;
                const url = new URL(window.location.href);
                url.searchParams.set('round', round);
                history.replaceState(null, '', url);
            }

            function gameLogic(square) {
                if (movesRemaining < 1) {
                    return;
                }
                movesRemaining--;
                var additionalScore = revealSquare(square);
                score += additionalScore;

                movesSinceLastComparison++;
                scoreSinceLastComparison += additionalScore;

                var comparersAdditionalScore = getComparersAdditional(additionalScore);
                comparersScore += comparersAdditionalScore;

                var idx = numberOfMoves - movesRemaining - 1; // rewrite this out to SOS
                decision[idx] = square;
                rewardReceived[idx] = additionalScore;
                comparison[idx] = comparersAdditionalScore;
                timeStamps[idx] = new Date().toISOString().split('T')[1];

                scoreText.innerHTML = 'Score: ' + score;
                movesText.innerHTML = 'Trials left: ' + movesRemaining;
                updateTextColor(scoreText, score, previousScore);

                previousScore = score;

                if (!comparisonOnNewPage && movesSinceLastComparison == comparisonFrequency) {
                  blockScreenForComparison();
                }

                if (movesRemaining < 1) {
                  endTrialLogic(scoresSoFar, comparersScoreSoFar);
                }
            }
            
            function blockScreenForComparison() {
              document.getElementById('no-comparison-trials').innerHTML = comparisonFrequency > 1 ? comparisonFrequency + ' trials,' : 'trial,';
              document.getElementById("player-score-since-last-comparison").innerHTML = scoreSinceLastComparison;
              document.getElementById("comparison-score-since-last-comparison").innerHTML = comparersScore;
              if (includeComparison && round % comparisonFrequencyRounds == 0) { // if it's not comparison round, then don't show anything
                document.getElementById("comparer-score-container").classList.add("score-container");
                document.getElementById("comparer-score-container").classList.remove("gone");
              } else { // else it's a comparison round
                document.getElementById("comparer-score-container").classList.remove("score-container");
                document.getElementById("comparer-score-container").classList.add("gone");
              }
              document.getElementById("comparison-information").classList.remove("gone");
              document.body.style.cursor = 'none !important';
              document.getElementById("overlay").style.display = 'block';

              setTimeout(() => {
                document.getElementById("read-comparison").style.visibility = 'visible';
                document.getElementById("comparison-information").addEventListener('click', function() {
                  overlay.style.display = 'none';
                  document.getElementById("comparison-information").classList.add('gone');
                  document.body.style.cursor = 'default';
                });
              }, 3000);

              movesSinceLastComparison = 0;
              scoreSinceLastComparison = 0;
              comparersScore = 0;
            }

            function endTrialLogic(scoresSoFar, comparersScoreSoFar) {
              saveTrainingData(decision, comparison, rewardReceived, timeStamps);
              document.getElementById("trialOver").classList.remove("gone");
              document.getElementById("trialOverBut").classList.remove("gone");
              scoresSoFar.push(score);
              comparersScoreSoFar.push(comparersScore);
              if (includeComparison && comparisonOnNewPage && (round % comparisonFrequencyRounds == 0)) {
                document.getElementById('trialOverBut').addEventListener('click', function() {
                  showPage('STANDINGS');
                });
              } else {
                document.getElementById('trialOverBut').addEventListener('click', function() {
                  showPage('INTERMEDIARY');
                });
              }
              round++;
              return;
            }

            function revealSquare(square) {
                square.classList.remove('grey');
                square.classList.add('white');
                const squareX = parseFloat(square.id.split(',')[0]);
                const squareY = parseFloat(square.id.split(',')[1]);
                var additionalScore = 0;
                var randomVal = Math.random();
                var currentMove = numberOfMoves - movesRemaining - 1;
                if (settings.rewardsChangeAcrossRounds) {
                  currentMove += ((round - 1) * numberOfMoves);
                }
                if (binary) {
                    if (randomVal < chanceToWin[currentMove][squareY][squareX]) { // CHANCE TO WIN IS HERE!
                      if (randomVal < chanceToWinPurple[currentMove][squareY][squareX]) {
                        additionalScore = purpleSquareScore;
                        makePurple(square, additionalScore);
                      } else {
                        additionalScore = greenSquareScore;
                        makeGreen(square, additionalScore);
                      }
                    }
                } else {
                    if (randomVal < chanceToWinPurple[currentMove][squareY][squareX]) {
                        additionalScore = purpleSquareScore;
                        makePurple(square, additionalScore);
                    } else {
                      additionalScore = Math.round(chanceToWin[currentMove][squareY][squareX] * 100);
                      makeGreen(square, additionalScore);
                    }
                }
                setTimeout(() => {
                    square.classList.remove('white');
                    square.classList.add('grey');
                }, 500);
                return additionalScore;
            }

            function makeGreen(square, additionalScore) {
                const pseudoElement = document.createElement('div');
                pseudoElement.classList.add('green');
                const text = document.createElement('div');
                text.classList.add('square-score');
                text.innerHTML = additionalScore;
                pseudoElement.appendChild(text);
                square.appendChild(pseudoElement);
                square.classList.add('greenish');
                setTimeout(() => {
                    square.classList.remove('greenish');
                    square.classList.remove('white');
                    square.classList.add('grey');
                    square.removeChild(pseudoElement);
                }, 700);
            }

            function makePurple(square, additionalScore) {
                const pseudoElement = document.createElement('div');
                pseudoElement.classList.add('gold');
                const text = document.createElement('div');
                text.classList.add('square-score');
                text.innerHTML = additionalScore;
                pseudoElement.appendChild(text);
                square.appendChild(pseudoElement);
                square.classList.add('goldish');
                setTimeout(() => {
                    square.classList.remove('goldish');
                    square.classList.remove('white');
                    square.classList.add('grey');
                    square.removeChild(pseudoElement);
                }, 700);
            }

            function updateTextColor(scoreText, score, previousScore) {
                const originalColor = 'black';
                var newColor = 'black';
                var timeout = 300;
                if ((score - previousScore) == greenSquareScore) {
                    newColor = '#228833';
                    timeout = 500;
                } else if ((score - previousScore) == purpleSquareScore) {
                    newColor = '#AA3377';
                    timeout = 500;
                } else if (score < previousScore) {
                    newColor = '#BBBBBB'; //red:#F05039
                }
                scoreText.style.color = newColor;
                setTimeout(() => {
                    scoreText.style.color = originalColor;
                }, timeout);
            }

            function getComparersAdditional(playersAdditionalScore) {
              var randomVal = Math.random();
              var currentMove = numberOfMoves - movesRemaining - 1;
              if (settings.rewardsChangeAcrossRounds) {
                currentMove += ((round - 1) * numberOfMoves);
              }
              // upward comparison
              if (Math.random() < probUpwardComparison) {
                if (binary) { 
                  return greenSquareScore;
                }
                if (settings.comparerUsesAvailableCards) {
                  return getUpwardComparisonAvailableValue(playersAdditionalScore, currentMove);
                }
                return playersAdditionalScore += Math.round(Math.min(additionalScore + gaussianRandom(comparisonMean, comparisonStdDev), 100));
              }
              // downward comparison
              if (binary) {
                return 0;
              }
              if (settings.comparerUsesAvailableCards) {
                return getDownwardLateralComparisonAvailableValue(playersAdditionalScore, currentMove);
              }
              return playersAdditionalScore += Math.round(Math.max(0, additionalScore - gaussianRandom(comparisonMean, comparisonStdDev)));
            }

            function getUpwardComparisonAvailableValue(playersAdditionalScore, currentMove) {
              const greenChances = chanceToWin[currentMove].flat(2);
              const purpleChances = chanceToWinPurple[currentMove].flat(2);
              
              if (settings.optimalValueComparison) {
                  if (purpleChances.some(chance => chance > 0)) { // purple is always optimal
                      return purpleSquareScore;
                  } else { // if no purple available
                      return Math.round(Math.max(...greenChances) * 100);
                  }
              } else {
                  var availableScores = greenChances.map(value => Math.round(value * 100)); // convert all green chances to scores
                  purpleChances.forEach(value => { // same for purple chances
                      if (value > 0) {
                          availableScores.push(purpleSquareScore);
                      }
                  });
                  shuffleArray(availableScores);
                  for (let val of availableScores) { // first value greater than playersAdditionalScore including purple
                      if (val > playersAdditionalScore) {
                          return val;
                      }
                  }
              }
              return playersAdditionalScore; // just in case
            }

            function getDownwardLateralComparisonAvailableValue(playersAdditionalScore, currentMove) {
              const flattenedCombinedArray = [ ...chanceToWin[currentMove].flat(2) ];
              shuffleArray(flattenedCombinedArray);
              for (let value of flattenedCombinedArray) {
                var val = Math.round(value * 100);
                if (val <= playersAdditionalScore) {// first value less than playersAdditionalScore
                  return val;
                }
              }
              return 0; // just in case
            }

            function setupGrid() {
              const padding = 10;
              const minDimension = Math.min(window.innerWidth, window.innerHeight - rows * padding);
              const squareSize = (minDimension / Math.max(rows, cols)) - padding;

              gridContainer.innerHTML = '';
              gridContainer.style.gridTemplateColumns = `repeat(${cols}, ${squareSize + padding}px)`;
              gridContainer.style.gridTemplateRows = `repeat(${rows}, ${squareSize + padding}px)`;

              createGridSquares(rows, cols, squareSize, padding);
            }

            function createGridSquares(rows, cols, squareSize, padding) {
              for (let y = 0; y < rows; y++) {
                  for (let x = 0; x < cols; x++) {
                      const square = createSquare(x, y, squareSize, padding);
                      gridContainer.appendChild(square);
                  }
              }
            }

            function createSquare(x, y, squareSize, padding) {
              const square = document.createElement('div');
              square.id = `${x},${y}`;
              square.classList.add('square');
              square.classList.add('grey');
              square.style.width = square.style.height = squareSize + 'px';
              square.style.borderRadius = '5px';
              square.style.margin = `${padding / 2}px`;

              square.addEventListener('click', function(event) {
                  if (isClickable) {
                      isClickable = false;
                      gameLogic(square);
                      setTimeout(() => {
                          isClickable = true;
                      }, 500); // 500 ms debounce time
                  }
              });

              return square;
            }

            function convertXY2Square(x, y) {
              return y * cols + x;
            }

            function convertXY2Square(x, y) {
              return gridSize * y + x;
            }

            function constructURLWithScores(scoresSoFar, comparersScoreSoFar) {
              let baseURL = new URL(window.location.href.split('?')[0]);
              baseURL += '?round=' + round;
              scoresSoFar.forEach((score, index) => {
                  baseURL += '&score' + (index + 1) + '=' + score;
              });
              comparersScoreSoFar.forEach((score, index) => {
                  baseURL += '&n3ssiori' + (index + 1) + '=' + score;
              });
              history.replaceState(null, '', baseURL);
            }

            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [array[i], array[j]] = [array[j], array[i]];
              }
            }

            function gaussianRandom(mean=0, stdev=1) { //stackOverflow
              const u = 1 - Math.random(); // Converting [0,1) to (0,1]
              const v = Math.random();
              const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
              // Transform to the desired mean and standard deviation:
              return z * stdev + mean;
            }

            function saveTrainingData(decision, comparison, rewardReceived, timeStamps) {
              // Create the main object with the trainingData label
              const data = {
                      move: {}
              };

              // Populate the trainingData object
              let squareX;
              let squareY;
              decision.forEach((square, index) => {
                  squareX = parseFloat(square.id.split(',')[0]);
                  squareY = parseFloat(square.id.split(',')[1]);
                  data.move[index] = {
                      decisionX: squareX,
                      decisionY: squareY,
                      reward: rewardReceived[index],
                      comparison: comparison[index],
                      timestamp: timeStamps[index]
                  };
              });

              // Convert the data object to a JSON string
              const dataJSON = JSON.stringify(data);

              // Store the JSON string in sessionStorage
              sessionStorage.setItem(round, dataJSON);
            }
        }

        function loadIntermediary() {
            const urlParams = new URLSearchParams(window.location.search);
            const finalRound = settings.numberOfRounds;
            urlParams.set('round', round); // Update the 'round' parameter with the new value
            const latestScore = scoresSoFar.at(-1);

            const scoreDiv = document.getElementById('scorer');
            if (scoreDiv) {
                scoreDiv.innerHTML = "You scored: " + latestScore;
            }
            if (round <= finalRound) {
                document.getElementById('rounder').innerHTML = "Next Round? Round " + round + " of " + finalRound;
                buttonToNewPage('rounder', 'GAME');
            } else {
                document.getElementById('rounder').innerHTML = "Complete participation";
                buttonToNewPage('rounder', 'THANKS');
            }
        }


        function loadStandings() {
            const urlParams = new URLSearchParams(window.location.search);
            const finalRound = settings.numberOfRounds;
            urlParams.set('round', round); // Update the 'round' parameter with the new value

            const scoresSum = scoresSoFar.reduce((total, score) => total + score, 0);
            const socialScoresSum = comparersScoreSoFar.reduce((total, comparersScoreSoFar) => total + comparersScoreSoFar, 0);
            /*const avgScore = (scoresSum / scoresSoFar.length).toFixed(1);*/
            const avgScore = Math.max(...scoresSoFar);
            const avgSocialScore = Math.max(...comparersScoreSoFar);

            const data = [
                { name: "n3ssiori", score: 0 },
                { name: "You", score: 0 } // init for animation
            ];

            // Create SVG container
            const svg = d3.select("#barChart");

            // Set margins and dimensions
            const margin = { top: 20, right: 30, bottom: 30, left: 40 };
            const width = +svg.attr("width") - margin.left - margin.right;
            const height = +svg.attr("height") - margin.top - margin.bottom;

            // Create scales
            const xScale = d3.scaleBand()
                .rangeRound([0, width])
                .padding(0.1)
                .domain(data.map(d => d.name));

            const ymax = socialScoresSum;
            let ymin = 0;
            if (avgScore < 0) {
              ymin = avgScore;
            }
            const yScale = d3.scaleLinear()
                .rangeRound([height, 0])
                .domain([ymin, ymax]);

            // Create axes
            const xAxis = d3.axisBottom(xScale);

            // Append axes
            svg.append("g")
              .attr("transform", `translate(${margin.left}, ${yScale(0) + margin.top})`)
              .call(xAxis);

            var youTick = svg.selectAll(".tick text").filter(function() { return d3.select(this).text() === "You"; })
            youTick.attr("fill", "#1F449C");
            if (avgScore < 0) {
              youTick.attr("dy", "-1em");
            }

            // Create initial bars
            const bars = svg.selectAll(".bar")
              .data(data)
              .enter().append("rect")
              .attr("class", "bar")
              .attr("x", d => xScale(d.name) + margin.left)
              .attr("y", d => yScale(d.score) + margin.top)
              .attr("width", xScale.bandwidth())
              .attr("height", d => 0);

            // Add text labels
            svg.selectAll(".bar-label")
              .data(data)
              .enter().append("text")
              .attr("class", "bar-label")
              .attr("x", d => xScale(d.name) + margin.left + xScale.bandwidth() / 2)
              .attr("y", d => yScale(0) - margin.top + 50)
              .attr("text-anchor", "middle")
              .attr("fill", "transparent")
              .text(d => Math.round(d.score));

            function updateSocialBar(player1Score) {
              data[0].score = player1Score;

              // Update scales
              const maxScore = Math.max(avgSocialScore, avgScore);
              const minScore = Math.min(0, avgScore);
              yScale.domain([minScore, maxScore]);

              // Update "Player 1" score with animation
              bars.filter(d => d.name === "n3ssiori")
                .transition()
                .duration(2000)
                .attr("y", d => yScale(Math.max(0, d.score)) + margin.top)
                .attr("height", d => Math.abs(yScale(0) - yScale(d.score)));

              // Update text labels
              svg.selectAll(".bar-label")
                .data(data)
                .filter(d => d.name === "n3ssiori")
                .text(d => Math.round(d.score)) // Update text content with score
                .transition()
                .duration(2000)
                .attr("fill", "white")
                .attr("y", d => yScale(Math.max(0, d.score)) + margin.top + 20);
            }

            function updatePlayerBar(avgScore) {
              data[1].score = avgScore;

              // Update scales
              const maxScore = Math.max(avgSocialScore, avgScore);
              const minScore = Math.min(0, avgScore);
              yScale.domain([minScore, maxScore]);

              // Update "You" score with animation
              bars.filter(d => d.name === "You")
                  .transition()
                  .duration(2000)
                  .attr("y", d => yScale(Math.max(0, d.score)) + margin.top)
                  .attr("height", d => Math.abs(yScale(0) - yScale(d.score)));

              svg.selectAll(".bar-label")
                .data(data)
                .filter(d => d.name === "You")
                .text(d => Math.round(d.score)) // Update text content with score
                .transition()
                .duration(2000)
                .attr("fill", d => Math.abs(yScale(0) - yScale(d.score)) < 50 ? "black" : "white") // Conditionally change text color
                .attr("y", d => {
                  const barHeight = Math.abs(yScale(0) - yScale(d.score));
                  if (barHeight < 50) {
                    if (avgScore < 0) {
                      return yScale(Math.max(0, d.score)) + margin.top + 20;// Move text below bar
                    } else {
                      return yScale(Math.max(0, d.score)) + margin.top - 5;// Move text above bar
                    } 
                  } else {
                    return yScale(Math.max(0, d.score)) + margin.top + 20; // Default position
                  }
                });
            }

            // Update scores with some delay to see the animation
            setTimeout(() => {
                updateSocialBar(avgSocialScore);
            }, 500); // Delay
            
            setTimeout(() => {
                updatePlayerBar(avgScore);
            }, 2500); // Delay

            const standingsButt = document.getElementById('next-round-button');

            standingsButt.disabled = true;
            standingsButt.style.cursor = 'not-allowed'; // Change cursor to not-allowed

            if (round <= finalRound) {
                standingsButt.innerHTML = "Next Round? Round " + round + " of " + finalRound;
                buttonToNewPage('next-round-button', 'GAME');
            } else {
                standingsButt.innerHTML = "Complete participation";
                buttonToNewPage('next-round-button', 'THANKS');
            }

            setTimeout(() => {
                standingsButt.disabled = false;
                standingsButt.classList.add('enabled');
                standingsButt.style.cursor = 'pointer';
            }, 6000);
        }


        function loadThanks() {
            const round = getUrlParameter('round');
            const finalRound = getUrlParameter('rounds');

            /*const avgScore = (scoresSum / scoresSoFar.length).toFixed(1);*/
            const maxScore = Math.max(...scoresSoFar);
            var playerRowMax = document.getElementById('player-score-max');
            if (playerRowMax) {
              playerRowMax.innerHTML = maxScore;
            }

            const scoresSum = scoresSoFar.reduce((total, score) => total + score, 0);
            var playerRowSum = document.getElementById('player-score-sum');
            if (playerRowSum) {
              playerRowSum.innerHTML = scoresSum;
            }

            let maximumPossible = sumHighestValues(settings.chanceToWin) * 100;
            let bonus = 5 * (scoresSum / maximumPossible);
            document.getElementById('bonus-calculation').innerHTML = '€' + bonus.toFixed(2);

            var genderSelect = document.getElementById('gender');
            var ageSelect = document.getElementById('age');
            var option = document.createElement('option');
            option.value = "prefer-not-to-say";
            option.text = 'Prefer not to say';
            ageSelect.appendChild(option);
            for (var i = 18; i <= 99; i++) {
              var option = document.createElement('option');
              option.value = i;
              option.text = i;
              ageSelect.appendChild(option);
            }
            document.getElementById('final-payment').addEventListener('click', function() {
              var storedData = sessionStorage.getItem('playerData');
              var existingData = storedData ? JSON.parse(storedData) : {};
              var additionalUserData = {
                  "player": {
                      "gender": genderSelect.value,
                      "age": ageSelect.value
                  }
              };

              // Merge additional user data with existing user data
              existingData.player = Object.assign({}, existingData.player, additionalUserData.player);
              const comment = document.getElementById('comments').value;
              existingData.comment = comment;
              var mergedDataString = JSON.stringify(existingData);

              sessionStorage.setItem('playerData', mergedDataString);

              showPage('FINAL');
            });

            function sumHighestValues(chanceToWin) {
              let sum = 0;
              for (let i = 0; i < chanceToWin.length; i++) {
                  for (let j = 0; j < chanceToWin[i].length; j++) {
                      let highestValue = Math.max(...chanceToWin[i][j]);
                      sum += highestValue;
                  }
              }
              return sum;
            };
        }


        function loadRescinded() {
            
        }


        function loadFinal() {
            const prolificID = JSON.parse(sessionStorage.getItem('playerData')).player.prolificID;
            var data = {};
            Object.keys(sessionStorage).forEach(function(key) {
              data[key] = JSON.parse(sessionStorage.getItem(key));
            });
            send_complete(prolificID, JSON.stringify(data, null, 2));
        }



        function getUrlParameter(name) {
          const urlParams = new URLSearchParams(window.location.search);
          return urlParams.get(name) || '';
        }

        function getScoresSoFar() {
          const urlParams = new URLSearchParams(window.location.search);
          const scores = [];
          urlParams.forEach((value, key) => {
              if (key.startsWith('score')) {
                  scores.push(parseFloat(value));
              }
          });
          return scores;
        }

        function getComparersScoresSoFar() {
          const urlParams = new URLSearchParams(window.location.search);
          const scores = [];
          urlParams.forEach((value, key) => {
              if (key.startsWith('n3ssiori')) {
                  scores.push(parseFloat(value));
              }
          });
          return scores;
        }

        function getGameSettings() {
            const settings = sessionStorage.getItem('gameSettings');
            return settings ? JSON.parse(settings) : {};
        }

        function nextRound() {
          const urlParams = new URLSearchParams(window.location.search);
          let round = urlParams.get('round');
          round = parseInt(round) + 1; // Convert to integer and increment by one
          urlParams.set('round', round); // Update the 'round' parameter with the new value
          let newUrl = 'game?';
          urlParams.forEach((value, key) => {
              newUrl += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(value);
          });
          window.location.href = newUrl;
        }

        function buttonToNewPage(buttonId, newPageID) {
          document.getElementById(buttonId).addEventListener('click', function() {
            addToInstructionTimings(buttonId, new Date().toISOString().split('T')[1]);
            showPage(newPageID);
          });
        }

        function addToInstructionTimings(buttonId, timestamp) {
          let instructionTimings = JSON.parse(sessionStorage.getItem('instructionTimings'));

          if (!instructionTimings) {
            instructionTimings = {
              instruction: {}
            };
          }

          instructionTimings.instruction[buttonId] = {
            time: timestamp
          };

          sessionStorage.setItem('instructionTimings', JSON.stringify(instructionTimings));
        }

        function initializeFocusTracker() {
          // Initialize focus object in sessionStorage if not already exists
          if (!sessionStorage.getItem('focus')) {
            const initialFocus = {};
            sessionStorage.setItem('focus', JSON.stringify(initialFocus));
          }

          // Function to update focus data in sessionStorage
          function updateFocusData(focusType) {
            const focusData = JSON.parse(sessionStorage.getItem('focus')) || {};
            const currentTime = new Date().toISOString().split('T')[1];
            if (!focusData[currentPage]) {
              focusData[currentPage] = {
                'in-focus': [],
                'out-focus': []
              };
            }
            focusData[currentPage][focusType].push(currentTime);
            sessionStorage.setItem('focus', JSON.stringify(focusData));
          }

          // Event listener for visibility change
          document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === 'visible') {
              updateFocusData('in-focus');
            } else {
              updateFocusData('out-focus');
            }
          });
        }

        function checkRefresh() {
          const hasConsentRescinded = JSON.parse(sessionStorage.getItem('focus')).hasOwnProperty('consent-rescinded');
          const pageAccessedByReload = (
            (window.performance.navigation && window.performance.navigation.type === 1) ||
              window.performance
                .getEntriesByType('navigation')
                .map((nav) => nav.type)
                .includes('reload')
          );
          if (pageAccessedByReload || hasConsentRescinded) {
            showPage('RESCINDED');
          }
        }
        
        
        // The backend URL is composed of a hostname (localhost for testing, kyblab2.etc
        // for running) and a port (which is specific to a particular experiment)
        // These should be set for each experiment
        const BACKEND_HOST = "http://127.0.0.1";
        const BACKEND_PORT = "8000";
        const BACKEND_URL = `${BACKEND_HOST}:${BACKEND_PORT}`;

        // These are the routes the backend understands. They allow creation of a new
        // participant, saving of complete or incomplete data, and finalisation of the
        // experiment
        const CREATE_PATH = "create";
        const COMPLETE_SAVE_PATH = "complete";
        const INCOMPLETE_SAVE_PATH = "incomplete";
        const COMPLETE_SUCCESS_PATH = "complete_success";
        const COMPLETE_FAILURE_PATH = "complete_failure";

        /**
         * Notify the server that there is a new participant. This will generate and
         * return a new internal ID for that participant. The ID will be null in the
         * case that the prolific id has been seen before
         * 
         * @param pid The prolific id of the new participant 
         * @returns A promise of json with the value "id": "SOMERANDOMSTRING" for the
         * new participant, or "id": null if the pid is not unique
         */
        async function create_participant(pid) {
          const response = await fetch(`${BACKEND_URL}/${CREATE_PATH}/${pid}`, {
            keepalive: true,
            method: 'POST',
          });
          return response.json();
        }

        /**
         * Sends incomplete data (e.g. after each trial) to the backend to be saved. The
         * backend will save it in a directory of incomplete data.
         *
         * @param id The internal id of the participant 
         * @param data The data to be saved
         */
        function send_incomplete(id, data) {
          var xhr = new XMLHttpRequest();
          xhr.open('POST', `${BACKEND_URL}/${INCOMPLETE_SAVE_PATH}/${id}`);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.send(JSON.stringify(data));
        }

        /**
         * Sends completed data to the backend to be saved. The
         * backend will remove any incomplete data, and write the completed data to the
         * completed data directory
         *
         * @param id The internal id of the participant 
         * @param data The data to be saved
         */
        function send_complete(id, data) {
          var xhr = new XMLHttpRequest();
          xhr.open('POST', `${BACKEND_URL}/${COMPLETE_SAVE_PATH}/${id}`);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.send(JSON.stringify(data));
        }

        /**
         * Notifies the backend of the success or failure of the experiment. This will
         * cause the backend to move any saved data to either the completed or the
         * invalid data directories
         *
         * @param id The internal id of the participant 
         * @param data Whether or not the participant completed the experiment
         * succesfully
         */
        function complete(id, success = true) {
          var xhr = new XMLHttpRequest();
          var path = COMPLETE_SUCCESS_PATH;
          if (!success) {
            path = COMPLETE_FAILURE_PATH;
          }
          xhr.open('POST', `${BACKEND_URL}/${path}/${id}`);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.send(null);
        }

        /**
         * Parse the prolific user id out of the url.
         * The id is a String variable with identifier "PROLIFIC_PID" that is automatically set when a 
         * participant was redirected to the website by prolific.
         * 
         * @returns Prolific user id (String) or None if no user id was found 
         */
        function get_prolific_id() {
          // parse our prolific user id from URL parameters
          var queryString = window.location.search;
          var urlParams = new URLSearchParams(queryString);
          var prolific_participant_id = urlParams.get('PROLIFIC_PID')
          return prolific_participant_id
        }
    </script>
</body>
</html>