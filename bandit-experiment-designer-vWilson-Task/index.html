<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <title>Grouped & Sampled Bandit Matrices</title>  <style>    body {      font-family: monospace;      white-space: pre;      margin: 0;      padding: 1em;      background: #f9f9f9;    }    .box {      max-height: 40vh;      overflow: auto;      background: #fff;      padding: 1em;      border: 1px solid #ccc;      margin-bottom: 2em;    }    .header {      font-weight: bold;      margin-bottom: 0.5em;    }    button {      margin-right: 1em;      padding: 0.5em 1em;    }  </style></head><body>  <h1>Two-Armed Bandit: Grouped & Sampled</h1>  <button id="save-settings">💾 Save Settings</button>  <button id="simulate">🤖 Run Simulations</button>  <div class="header">Full Grouped Listing by Posterior Means</div>  <div id="grouped" class="box">Generating…</div>  <div class="header">Sampled 320 Matrices (≈Equal per Bucket though less for equal probs)</div>  <div id="sampled" class="box">Sampling…</div>  <script>  // Constants  const rewardValues = [1, 2, 3, 4, 5, 6];  const posteriorValues = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];  const length       = 4;  const PRIOR_ALPHA  = 1;  const PRIOR_BETA   = 1;  const TOTAL_SAMPLES = 400;  let chanceToWin = {};  let numberOfRounds = 0;  const movesShort = 5;  const movesLong = 10;  const rows = 1;  const cols = 2;  const includeComparison = false;  // Init and generate  (function init() {    const flags = genFlags(length);    const entries = [];    for (const mu1 of rewardValues) {      for (const mu2 of rewardValues) {        for (const f1 of flags) {          for (const f2 of flags) {            let s1 = 0, s2 = 0;            const matrix = [];            for (let t = 0; t < length; t++) {              const r1 = f1[t]*mu1, r2 = f2[t]*mu2;              if (r1 > 0) s1++;              if (r2 > 0) s2++;              matrix.push([r1, r2]);            }            const p1 = (PRIOR_ALPHA + s1) / (PRIOR_ALPHA + PRIOR_BETA + length);            const p2 = (PRIOR_ALPHA + s2) / (PRIOR_ALPHA + PRIOR_BETA + length);            entries.push({ mu: [mu1, mu2], matrix, posterior: [p1, p2] });          }        }      }    }    const buckets = {};    entries.forEach(e => {      const key = e.posterior.map(p => p.toFixed(3)).join(',');      if (!buckets[key]) buckets[key] = [];      buckets[key].push(e);    });    // Render grouped output    const gOut = [`Total matrices: ${entries.length}\n`];    Object.keys(buckets).sort().forEach(key => {      const b = buckets[key];      gOut.push(`---\nPosterior = [${key}]  (${b.length} matrices)\n`);      b.forEach((e,i) => {        gOut.push(`  • μ=[${e.mu.join(',')}], #${i+1}`);        e.matrix.forEach(r => gOut.push(`      [${r.join(',')}]`));      });      gOut.push('');    });    document.getElementById('grouped').textContent = gOut.join('\n');    // Sample from buckets    const keys = Object.keys(buckets).sort();    const B = keys.length;    const equalBuckets = keys.filter(k => k.split(",")[0] === k.split(",")[1]);    const sampleForEqualProb = 2;    const equalProbSampleBase = equalBuckets.length * sampleForEqualProb;    const base = Math.floor((TOTAL_SAMPLES - equalProbSampleBase) / (B - equalBuckets.length));    let remain = TOTAL_SAMPLES - base * B;    const sampled = [];    keys.forEach(key => {      const bucket = [...buckets[key]];      shuffle(bucket);      const isEqual = key.split(",")[0] === key.split(",")[1];      const take = isEqual ? sampleForEqualProb + (remain > 0 ? 1 : 0)                           : base + (remain > 0 ? 1 : 0);      sampled.push(...bucket.slice(0, take));      if (remain > 0) remain--;    });    // Render sampled matrices    const sOut = [`Total sampled: ${sampled.length}\n`];    sampled.forEach((e,i) => {      sOut.push(`#${i+1}  μ=[${e.mu.join(',')}], posterior=[${e.posterior.map(p => p.toFixed(3)).join(',')}]:`);      e.matrix.forEach(r => sOut.push(`     [${r.join(',')}]`));    });    document.getElementById('sampled').textContent = sOut.join('\n');    // Save to global for simulations    shuffle(sampled);    numberOfRounds = sampled.length;    sampled.forEach((e, i) => {      chanceToWin[`round_${i+1}`] = {        mean:      e.mu,        posterior: discretizePosterior(e.posterior, 10),        firstFour: e.matrix.slice(0, length)      };    });  })();  // Event listeners  document.getElementById('save-settings').addEventListener('click', () => {    const id = 1;    const settings = {      vars: {        id,        movesShort,        movesLong,        fixedFirstMoves: length,        rows,        cols,        numberOfRounds,        includeComparison      },      chanceToWin    };    saveJSON(settings, 'settings.json');  });  document.getElementById('simulate').addEventListener('click', () => {    const id = makeid(5);    const settings = {      vars: {        id,        movesShort,        movesLong,        fixedFirstMoves: length,        rows,        cols,        numberOfRounds,        includeComparison      },      chanceToWin    };    saveJSON(settings, `settings_${id}.json`);    const randomSim   = runSimulations('random');    const gradientSim = runSimulations('gradient');    saveJSON(randomSim, `randomSimulationResults_${id}.json`);    saveJSON(gradientSim, `gradientSimulationResults_${id}.json`);  });  // Helper Functions  function softDiscreteDraw(currentPosterior, β = 10) {    // β: “inverse-temperature” — higher β makes you pick nearest levels more often        // compute raw weights    const raw = posteriorValues.map(l => Math.exp(-β * Math.abs(l - currentPosterior)));        // normalize    const sum  = raw.reduce((a,b) => a + b, 0);    const probs = raw.map(w => w / sum);    let r = Math.random(), cum = 0;    for (let i = 0; i < posteriorValues.length; i++) {      cum += probs[i];      if (r < cum) return posteriorValues[i];    }    return posteriorValues[posteriorValues.length - 1]; // fallback  }  function discretizePosterior(posterior, β) {    return posterior.map(p => softDiscreteDraw(p, β));  }  function genFlags(L) {    if (L === 0) return [[]];    const prev = genFlags(L - 1);    return prev.map(s => [0, ...s]).concat(prev.map(s => [1, ...s]));  }  function shuffle(arr) {    for (let i = arr.length - 1; i > 0; i--) {      const j = Math.floor(Math.random() * (i + 1));      [arr[i], arr[j]] = [arr[j], arr[i]];    }  }  function saveJSON(data, filename) {    const json = JSON.stringify(data, null, 2);    const blob = new Blob([json], { type: 'application/json' });    const a = document.createElement('a');    a.download = filename;    a.href = URL.createObjectURL(blob);    document.body.appendChild(a);    a.click();    document.body.removeChild(a);  }  function makeid(length) {    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';    return Array.from({length}, () => chars[Math.floor(Math.random() * chars.length)]).join('');  }  function runSimulations(agentType) {    const simulationResults = [];    for (let round = 0; round < numberOfRounds; round++) {      const agent = getNewAgentFromType(agentType);      let roundResult = [];      let numberOfMoves = Math.random() < 0.5 ? movesShort : movesLong;      for (let trial = 0; trial < numberOfMoves; trial++) {        roundResult = runTrial(agent, trial, roundResult, round);      }      simulationResults.push({ [`round_${round+1}`]: roundResult });    }    return simulationResults;    function runTrial(agent, trial, roundResult, round) {      const decision = agent.nextDecision();      let reward = 0;      const rewardsForThisRound = chanceToWin[`round_${round+1}`];      if (trial < length) {        reward = rewardsForThisRound.firstFour[trial][decision];      } else {        reward = (Math.random() < rewardsForThisRound.posterior[decision]) ? rewardsForThisRound.mean[decision] : 0;      }      agent.update(decision, reward);      agent.updatePreviousDecision(decision);      roundResult.push({ trial, decision, reward });      return roundResult;    }    function getNewAgentFromType(type) {      if (type === 'gradient') return new GradientBanditAgent(2, 0.1);      return new RandomAgent();    }  }  // Agent Classes  class Agent {    constructor(numActions = cols) {      this.numActions = numActions;      this.previousDecision = -1;    }    updatePreviousDecision(previous) {      this.previousDecision = previous;    }    nextDecision() { return 1; }    update() {}  }  class RandomAgent extends Agent {    nextDecision() {      return Math.floor(Math.random() * this.numActions);    }  }  class GradientBanditAgent extends Agent {    constructor(numActions, alpha = 0.1) {      super(numActions);      this.alpha = alpha;      this.H = Array(numActions).fill(0);      this.avgR = 0;      this.numDecisionsMade = 0;    }    nextDecision() {      const exps = this.H.map(h => Math.exp(h));      const sum = exps.reduce((a, b) => a + b, 0);      const probs = exps.map(e => e / sum);      let r = Math.random(), cum = 0;      for (let i = 0; i < probs.length; i++) {        cum += probs[i];        if (r < cum) return i;      }      return this.numActions - 1;    }    update(action, reward) {      const exps = this.H.map(h => Math.exp(h));      const sum = exps.reduce((a, b) => a + b, 0);      const probs = exps.map(e => e / sum);      const baseline = this.avgR;      const delta = reward - baseline;      for (let a = 0; a < this.numActions; a++) {        this.H[a] += this.alpha * delta * ((a === action ? 1 : 0) - probs[a]);      }      this.numDecisionsMade++;      this.avgR += (reward - this.avgR) / this.numDecisionsMade;    }  }  </script></body></html>